/*п. 1*/

//var a = 1, b = 1, c, d;
//
//c = ++a; alert(c); // 2 - бинарный оператор стоит перед значением, поэтому инкремент срабатывает во время присвоения
//
//d = b++; alert(d); // 1 - бинарный оператор стоит после значения, поэтому сначала происходит присвоение значения, без инкремента. При следующем вызове значение уже будет увеличено.
//
//c = (2+ ++a); alert(c); // 5 - выше а уже было увеличено до двух. Сейчас перед ним снова инкремент, т.е а = 3 уже в момент сложения. Прибавив его к 2 получаем 5.
//
//d = (2+ b++); alert(d); // 4 - выше b было увеличено с 1 до 2, но уже после присвоения своего значения переменной d, т. к. бинарный оператор стоял справа. По этой же причине b станет равно 3, но уже при следующем задействовании в операции, как и в прошлый раз. Пока берется еще не увеличенное значение b - 2, прибавив его к 2, получаем 4.
//
//alert(a); // 3 - причина описана в последнем пересчете переменной c: a уже была увеличена до 3 и с тех пор не менялась.
//
//alert(b); // 3 - причина описана в последнем пересчете переменной d: при последнем вызове b участвовала в операции с правым инкрементом, поэтому к текущему моменту инкремент сработал, увеличив знаение с 2 до 3. 



/*п. 2*/

//var a = 2;
//var x = 1 + (a *= 2);

// x = 5 - умножения a самой себя на 2 происходит в скобках, пожтому эта операция производится первой, потом прибавляется 1.



/*п. 3*/

//var a = -2;
//var b = 12;
//
//if(a >= 0 && b >= 0){
//    alert(a - b);
//} else if (a < 0 && b < 0){
//    alert(a * b);
//} else {
//    alert(a + b);
//}



/*п. 4*/

//var a = Math.round(Math.random()*15);
//switch(a){
//    case 0: 
//        if(a < 0){
//            alert(0);
//        }
//    case 1: 
//        if(a < 1){
//            alert(1);
//        }
//    case 2: 
//        if(a < 2){
//            alert(2);
//        }
//    case 3: 
//        if(a < 3){
//            alert(3);
//        }
//    case 4: 
//        if(a < 4){
//            alert(4);
//        }
//    case 5: 
//        if(a < 5){
//            alert(5);
//        }
//    case 6: 
//        if(a < 6){
//            alert(6);
//        }
//    case 7: 
//        if(a < 7){
//            alert(7);
//        }
//    case 8: 
//        if(a < 8){
//            alert(8);
//        }
//    case 9: 
//        if(a < 9){
//            alert(9);
//        }
//    case 10: 
//        if (a <= 10){
//            alert(10);
//        } 
//    case 11: 
//        if (a <= 11){
//            alert(11);
//        } 
//    case 12: 
//        if (a <= 12){
//            alert(12);
//        } 
//    case 13: 
//        if (a <= 13){
//            alert(13);
//        } 
//    case 14: 
//        if (a <= 14){
//            alert(14);
//        } 
//    case 15: 
//        if (a <= 15){
//            alert(15);
//        } 
//        break;     
//}

///*п. 5*/
//var z = 0;
//function sum(a, b){
//    z = +a + +b;
//    return z;
//}
//function subst(a, b){
//    z = +a - +b;
//    return z;
//}
//function mult(a, b){
//    z = +a * +b;
//    return z;
//}
//function div(a, b){
//    z = +a / +b;
//    return z;
//}
//
///*п. 6*/
//
//function mathOperation(arg1, arg2, operation){
//    switch(operation){
//        case '+':
//            sum(arg1, arg2);
//            alert(z);
//            break;
//        case '-':
//            subst(arg1, arg2);
//            alert(z);
//            break;
//        case '*':
//            mult(arg1, arg2);
//            alert(z);
//            break;
//        case '/':
//            div(arg1, arg2);
//            alert(z);
//            break;
//        default:
//            alert('Неправильные данные');
//    }
//}
//
//
//var x = prompt('Первое число:', 0);
//var y = prompt('Второе число:', 0);
//var o = prompt('Оператор, доступны "+", "-", "*" или "/"', '');
//mathOperation(x, y, o);


/*п. 7*/

//var a = null;
//var b = 0;
//console.log(a != b);
//console.log(a == b);
//console.log(a > b);
//console.log(a < b);
//
/*
Неравно - единственное верное обозначения отношения 0 и null. По спецификации https://www.ecma-international.org/ecma-262/5.1/#sec-4.3.11  это "специально оставленное незаполненным значение объекта". Проводя аналогию, true или 1 - это ящик с содержимым, false или 0 - это пустой ящик, undefined - отсутствие ящика вообще, а null - табличка "Здесь должен быть ящик. Или нет, но место все равно занято". Вероятно, пригодится для заполнения необязательных значений, которые в дальнейшем отфильтровываются каким-то алгоритмом на предмет true/false.
*/


